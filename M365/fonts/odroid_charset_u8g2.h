#pragma once
#include <Arduino.h>

// Generated from service.odroidn2.oled charset.py datasets
// Each set encodes digits 0..9 plus colon where available.
// We store compact PROGMEM bitmaps and provide simple blitters for U8g2.
// Note: For space, we keep raw rows as provided and plot non-zero bytes as pixels.

namespace OdroidCharset {

// FiveBySevenFullset: width=5, height=7, 1 byte/row, stride=6
static const uint8_t fiveBySevenMeta[5] PROGMEM = {5,7,1,6,0};
static const uint8_t fiveBySevenGlyphs[10][5] PROGMEM = {
  {0x3e,0x51,0x49,0x45,0x3e}, // 0
  {0x00,0x42,0x7f,0x40,0x00}, // 1
  {0x42,0x61,0x51,0x49,0x46}, // 2
  {0x21,0x41,0x45,0x4b,0x31}, // 3
  {0x18,0x14,0x12,0x7f,0x10}, // 4
  {0x27,0x45,0x45,0x45,0x39}, // 5
  {0x3c,0x4a,0x49,0x49,0x30}, // 6
  {0x01,0x71,0x09,0x05,0x03}, // 7
  {0x36,0x49,0x49,0x49,0x36}, // 8
  {0x06,0x49,0x49,0x29,0x1e}  // 9
};

// SevenByNine: width=7, height=9, 2 bytes/row, stride=8
static const uint8_t sevenByNineMeta[5] PROGMEM = {7,9,2,8,0};
static const uint8_t sevenByNineGlyphs[10][14] PROGMEM = {
  {0xfe,0xff,0x21,0x11,0x09,0xff,0xfe,0x00,0x01,0x01,0x01,0x01,0x01,0x00}, // 0
  {0x00,0x04,0xff,0xff,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00}, // 1
  {0x02,0x83,0xc1,0x61,0x31,0x1f,0x0e,0x01,0x01,0x01,0x01,0x01,0x01,0x01}, // 2
  {0x82,0x83,0x01,0x11,0x11,0xff,0xee,0x00,0x01,0x01,0x01,0x01,0x01,0x00}, // 3
  {0x30,0x38,0x2c,0x26,0xff,0xff,0x20,0x00,0x00,0x00,0x00,0x01,0x01,0x00}, // 4
  {0x8f,0x8f,0x09,0x09,0x09,0xf9,0xf1,0x00,0x01,0x01,0x01,0x01,0x01,0x00}, // 5
  {0xfe,0xff,0x09,0x09,0x09,0xfb,0xf2,0x00,0x01,0x01,0x01,0x01,0x01,0x00}, // 6
  {0x01,0xe1,0xf1,0x19,0x0d,0x07,0x03,0x00,0x01,0x01,0x00,0x00,0x00,0x00}, // 7
  {0xee,0xff,0x11,0x11,0x11,0xff,0xee,0x00,0x01,0x01,0x01,0x01,0x01,0x00}, // 8
  {0x9e,0xbf,0x21,0x21,0x21,0xff,0xfe,0x00,0x01,0x01,0x01,0x01,0x01,0x00}  // 9
};

// Dotmatrix small and large are more specialized block patterns; omit for now.
// SevenSeg sets similarly large; focusing on compact two sets above keeps binary small.

// Blitters: plot non-zero bytes as set bits across width; rows are provided MSB..LSB per byte row.
inline void drawGlyph5x7(uint8_t x, uint8_t y, uint8_t digit) {
  if (digit > 9) return;
  uint8_t w = 5, h = 7;
  for (uint8_t col = 0; col < w; ++col) {
    uint8_t colBits = pgm_read_byte(&fiveBySevenGlyphs[digit][col]);
    for (uint8_t ry = 0; ry < h; ++ry) if (colBits & (1 << ry)) display.drawPixel(x + col, y + ry);
  }
}

inline void drawGlyph7x9(uint8_t x, uint8_t y, uint8_t digit) {
  if (digit > 9) return;
  const uint8_t w = 7, h = 9;
  // Data is 2 bytes per column slice? In provided format, 14 bytes per glyph; map sequentially as columns.
  // We interpret first 7 bytes as top 8 bits, next 7 as bottom 1 bit.
  for (uint8_t col = 0; col < w; ++col) {
    uint8_t top = pgm_read_byte(&sevenByNineGlyphs[digit][col]);
    uint8_t bot = pgm_read_byte(&sevenByNineGlyphs[digit][7 + col]);
    for (uint8_t b = 0; b < 8; ++b) if (top & (1 << b)) display.drawPixel(x + col, y + b);
    if (bot & 0x01) display.drawPixel(x + col, y + 8);
  }
}

} // namespace
