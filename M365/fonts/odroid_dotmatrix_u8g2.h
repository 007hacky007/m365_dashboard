#pragma once
#include <Arduino.h>

// Auto-converted from service.odroidn2.oled charset.py (dotmatrix and dotmatrixLarge)
// Layout: column-major, byteHeight bytes per column (8 rows per byte), LSB at row offset
// Glyph order: digits '0'..'9'

namespace OdroidDotMatrix {

static const uint8_t DotMeta[3] PROGMEM = {14, 24, 3}; // width, height, byteHeight
static const uint8_t DotGlyphs[10][42] PROGMEM = {
  {0x60,0x60,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x60,0x60,0xdb,0xdb,0x00,0xc0,0xc0,0x00,0x18,0x18,0x00,0x03,0x03,0x00,0xdb,0xdb,0x06,0x06,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x06,0x06},
  {0x00,0x00,0x00,0x60,0x60,0x00,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xdb,0xdb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x36,0x36,0x00,0x30,0x30,0x00,0x00,0x00},
  {0x60,0x60,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0x00,0x18,0x18,0x00,0x03,0x03,0x30,0x30,0x00,0x36,0x36,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x30,0x30},
  {0x60,0x60,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x00,0xc3,0xc3,0x06,0x06,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x06,0x06},
  {0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x6c,0x6c,0x00,0x00,0x00,0xd8,0xd8,0x00,0xc3,0xc3,0x00,0xc0,0xc0,0x00,0xdb,0xdb,0x00,0xc0,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x36,0x00,0x00,0x00},
  {0x6c,0x6c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x03,0x03,0x00,0x03,0x03,0x00,0x03,0x03,0x00,0x03,0x03,0x00,0xd8,0xd8,0x06,0x06,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x06,0x06},
  {0x00,0x00,0x00,0x60,0x60,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x00,0x00,0xdb,0xdb,0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x18,0x18,0x00,0xc0,0xc0,0x06,0x06,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x06,0x06},
  {0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x6c,0x6c,0x00,0x00,0x00,0xc0,0xc0,0x00,0x18,0x18,0x00,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x60,0x60,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x60,0x60,0xc3,0xc3,0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x18,0x18,0x00,0xc3,0xc3,0x06,0x06,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x06,0x06},
  {0x60,0x60,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00,0x60,0x60,0x03,0x03,0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x18,0x18,0x00,0xdb,0xdb,0x00,0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x06,0x06,0x00,0x00,0x00}
};

// No dedicated large table; drawLarge scales DotGlyphs 2x

inline void drawSmall(uint8_t x, uint8_t y, uint8_t digit /*0-9*/){
  if (digit > 9) return; const uint8_t W=14, BH=3; const uint8_t* g = DotGlyphs[digit];
  for (uint8_t col=0; col<W; ++col){
    for (uint8_t bh=0; bh<BH; ++bh){
      uint8_t b = pgm_read_byte(&g[bh*W + col]);
      for (uint8_t bit=0; bit<8; ++bit) if (b & (1<<bit)) display.drawPixel(x+col, y + bh*8 + bit);
    }
  }
}
inline void drawLarge(uint8_t x, uint8_t y, uint8_t digit /*0-9*/){
  if (digit > 9) return; const uint8_t W=14, BH=3; const uint8_t* g = DotGlyphs[digit];
  const uint8_t S=2; // scale factor 2x
  for (uint8_t col=0; col<W; ++col){
    for (uint8_t bh=0; bh<BH; ++bh){
      uint8_t b = pgm_read_byte(&g[bh*W + col]);
      for (uint8_t bit=0; bit<8; ++bit) if (b & (1<<bit)) {
        uint8_t px = x + col*S; uint8_t py = y + (bh*8 + bit)*S;
        // 2x2 block
        display.drawPixel(px, py);
        display.drawPixel(px+1, py);
        display.drawPixel(px, py+1);
        display.drawPixel(px+1, py+1);
      }
    }
  }
}

} // namespace
